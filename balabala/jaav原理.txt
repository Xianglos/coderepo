jvm原理 
jvm的生命周期： 

诞生：启动java程序；任何的public static void main(String[] args)都可以作为起点 

运行：main()作为起点，其他线程都有它启动。 

          main属于非守护线程；守护线程通常由jvm自己使用，或者java程序自己标明自己是个守护线程。 

消亡：当 JVM 中不存在任何一个正在运行的非守护线程时，则 JVM 进程即会退出。 

          也可以使用java.lang.RunTime类、java.lang.System.exit()来退出。 

   

  比如在main()新建了一个线程A，线程写个死循环。 

  当主线程main()执行完毕后，jvm仍然不会退出，因为线程A是非守护线程，并且仍然在执行。 

  如果在新建线程A的时候，对线程A设置.setDaemon(true);//标记为守护进程 

  当main()执行完毕后，无论线程A有没有执行完，jvm都会退出。 

 

  非守护线程——用户线程 

  守护线程———后台线程 

  ↑↑↑这样好像便于理解，用户线程执行完了，jvm就可以关掉了。 

类的生命周期 

加载(Loading) → 验证(Verification) → 准备(Preparation) → 解析(Resolution) → 初始化(Initialization) → 使用(Using) → 卸载(Unloading) 

（验证、准备、解析，统称连接 

 

加载： 

验证：确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。 

  包括四个检验过程：文件格式验证、元数据验证、字节码验证、符号引用验证。 

文件格式的验证：是否符合Class文件的规范，以及能够被当前版本的虚拟机处理。 

元数据验证：对字节码描述的信息进行语义分析，以保证其描述符合java语法。 

字节码验证：主确定程序语义是合法的、符合逻辑的，防止方法在运行时，不会做出对虚拟机有危害的操作 

（比如类型赋值给父类型就很危险） 

符号引用验证： 

准备：为类变量（static变量）分配内存并设置类变量初始值 

  仅static变量，不包括实例变量；而且是设置为初期值，赋值的操作在初始化那一步 

解析：虚拟机常量池内的符号引用替换为直接引用的过程。 

  符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 

  直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。 

初始化： 

使用： 

卸载： 


类加载器 

启动类加载器（Bootstrap ClassLoader） 

负责放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库。 

用户无法直接使用。 

引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 

扩展类加载器（Extension ClassLoader） 

负责<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库。 

用户可以直接用 

应用程序类加载器（Application ClassLoader） 

负责ClassPath所指定的类库。 

用户可以直接使用。 

如果用户没有自己定义类加载器，默认使用这个。 

自定义类加载器（User ClassLoader） 

用户自己定义的类加载器 



双亲委派机制 

某个类加载器A需要加载B.class时，首先会把这个任务委托给上级的加载器，上级加载器会继续找更上级的加载器（递归），如果上级加载器都没有加载这个类，加载器A才会自己去加载B.class 

 

作用： 

防止B.class被重复加载 



方法区、堆、栈、程序计数器、本地方法栈 

方法区： 

堆： 

先进先出，线程共享 

存储对象实例和数组 

老年代、年轻代 

栈： 

先进后出，非线程共享 

每个线程都会创建自己的栈。 

栈里面是栈帧，每一个栈帧就是一个被调用的方法：调用一个方法时压栈，方法执行完毕后出栈，所以栈顶上是当前运行的方法 

程序计数器（Program Counter Register）： 

cpu在任意特定时刻，只能执行一条指令，所以对于多线程，每个线程都要记录自己被执行到哪里了 

什么垃圾翻译 

本地方法栈：